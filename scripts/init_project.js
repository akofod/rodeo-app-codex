#!/usr/bin/env node
/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');

const root = path.resolve(__dirname, '..');

const directories = [
  'app',
  'app/(public)',
  'app/(auth)',
  'app/(dashboard)',
  'app/api',
  'components',
  'components/ui',
  'components/forms',
  'components/layout',
  'lib',
  'lib/supabase',
  'lib/mapbox',
  'lib/validators',
  'types',
  'supabase',
  'supabase/migrations',
  'docs',
  'scripts',
];

const sprints = [
  'Sprint 1 (Foundation)',
  'Sprint 2 (Auth & Roles)',
  'Sprint 3 (Events & Venues)',
  'Sprint 4 (Services & Favorites)',
  'Sprint 5 (Admin, Maps, & SEO)',
];

const tasksContent = `# Tasks

${sprints.map((sprint) => `- [ ] ${sprint}`).join('\n')}
`;

const migrationSql = `-- Western Sports Hub initial schema

create extension if not exists "pgcrypto";

create type public.app_status as enum ('PENDING', 'APPROVED', 'REJECTED', 'ARCHIVED');
create type public.app_role as enum ('USER', 'ADMIN');

create table public.profiles (
  id uuid primary key references auth.users(id),
  email text,
  full_name text,
  role public.app_role not null default 'USER',
  created_at timestamptz not null default now()
);

create table public.venues (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  address_street text not null,
  address_city text not null,
  address_state text not null,
  address_zip text not null,
  latitude double precision,
  longitude double precision,
  website_url text,
  status public.app_status not null default 'PENDING',
  created_by uuid not null references public.profiles(id),
  created_at timestamptz not null default now()
);

create table public.disciplines (
  id integer generated by default as identity primary key,
  name text not null,
  slug text not null unique
);

create table public.sanctioning_bodies (
  id integer generated by default as identity primary key,
  name text not null,
  slug text not null unique,
  website_url text
);

create table public.events (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  venue_id uuid not null references public.venues(id),
  start_datetime timestamptz not null,
  flyer_image_url text,
  official_website_url text,
  classes_details text,
  status public.app_status not null default 'PENDING',
  created_by uuid not null references public.profiles(id),
  created_at timestamptz not null default now()
);

create table public.event_disciplines (
  event_id uuid not null references public.events(id) on delete cascade,
  discipline_id integer not null references public.disciplines(id),
  primary key (event_id, discipline_id)
);

create table public.event_sanctions (
  event_id uuid not null references public.events(id) on delete cascade,
  sanction_id integer not null references public.sanctioning_bodies(id),
  primary key (event_id, sanction_id)
);

create table public.services (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  category text not null,
  description text,
  phone text,
  website_url text,
  service_radius_miles integer not null,
  zip_code text not null,
  status public.app_status not null default 'PENDING',
  created_by uuid not null references public.profiles(id),
  created_at timestamptz not null default now()
);

create table public.favorites (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id),
  entity_id uuid not null,
  entity_type text not null,
  created_at timestamptz not null default now()
);

create or replace function public.is_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select coalesce(
    (select role = 'ADMIN' from public.profiles where id = auth.uid()),
    false
  );
$$;

alter table public.profiles enable row level security;
alter table public.venues enable row level security;
alter table public.disciplines enable row level security;
alter table public.sanctioning_bodies enable row level security;
alter table public.events enable row level security;
alter table public.event_disciplines enable row level security;
alter table public.event_sanctions enable row level security;
alter table public.services enable row level security;
alter table public.favorites enable row level security;

create policy "Profiles are viewable by owner"
on public.profiles
for select
using (id = auth.uid());

create policy "Profiles are insertable by owner"
on public.profiles
for insert
with check (id = auth.uid());

create policy "Profiles are updatable by owner"
on public.profiles
for update
using (id = auth.uid())
with check (id = auth.uid());

create policy "Admins can manage profiles"
on public.profiles
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view approved venues"
on public.venues
for select
using (status = 'APPROVED'::public.app_status);

create policy "Users can insert venues"
on public.venues
for insert
with check (created_by = auth.uid());

create policy "Users can update own venues"
on public.venues
for update
using (created_by = auth.uid())
with check (created_by = auth.uid());

create policy "Users can delete own venues"
on public.venues
for delete
using (created_by = auth.uid());

create policy "Admins can manage venues"
on public.venues
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view disciplines"
on public.disciplines
for select
using (true);

create policy "Admins can manage disciplines"
on public.disciplines
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view sanctioning bodies"
on public.sanctioning_bodies
for select
using (true);

create policy "Admins can manage sanctioning bodies"
on public.sanctioning_bodies
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view approved events"
on public.events
for select
using (status = 'APPROVED'::public.app_status);

create policy "Users can insert events"
on public.events
for insert
with check (created_by = auth.uid());

create policy "Users can update own events"
on public.events
for update
using (created_by = auth.uid())
with check (created_by = auth.uid());

create policy "Users can delete own events"
on public.events
for delete
using (created_by = auth.uid());

create policy "Admins can manage events"
on public.events
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view event disciplines for approved events"
on public.event_disciplines
for select
using (
  exists (
    select 1
    from public.events e
    where e.id = event_id
      and e.status = 'APPROVED'::public.app_status
  )
);

create policy "Users can manage event disciplines for own events"
on public.event_disciplines
for all
using (
  exists (
    select 1
    from public.events e
    where e.id = event_id
      and e.created_by = auth.uid()
  )
)
with check (
  exists (
    select 1
    from public.events e
    where e.id = event_id
      and e.created_by = auth.uid()
  )
);

create policy "Admins can manage event disciplines"
on public.event_disciplines
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view event sanctions for approved events"
on public.event_sanctions
for select
using (
  exists (
    select 1
    from public.events e
    where e.id = event_id
      and e.status = 'APPROVED'::public.app_status
  )
);

create policy "Users can manage event sanctions for own events"
on public.event_sanctions
for all
using (
  exists (
    select 1
    from public.events e
    where e.id = event_id
      and e.created_by = auth.uid()
  )
)
with check (
  exists (
    select 1
    from public.events e
    where e.id = event_id
      and e.created_by = auth.uid()
  )
);

create policy "Admins can manage event sanctions"
on public.event_sanctions
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Public can view approved services"
on public.services
for select
using (status = 'APPROVED'::public.app_status);

create policy "Users can insert services"
on public.services
for insert
with check (created_by = auth.uid());

create policy "Users can update own services"
on public.services
for update
using (created_by = auth.uid())
with check (created_by = auth.uid());

create policy "Users can delete own services"
on public.services
for delete
using (created_by = auth.uid());

create policy "Admins can manage services"
on public.services
for all
using (public.is_admin())
with check (public.is_admin());

create policy "Users can view own favorites"
on public.favorites
for select
using (user_id = auth.uid());

create policy "Users can insert own favorites"
on public.favorites
for insert
with check (user_id = auth.uid());

create policy "Users can update own favorites"
on public.favorites
for update
using (user_id = auth.uid())
with check (user_id = auth.uid());

create policy "Users can delete own favorites"
on public.favorites
for delete
using (user_id = auth.uid());

create policy "Admins can manage favorites"
on public.favorites
for all
using (public.is_admin())
with check (public.is_admin());
`;

const typesContent = `export type AppStatus = 'PENDING' | 'APPROVED' | 'REJECTED' | 'ARCHIVED';
export type AppRole = 'USER' | 'ADMIN';
export type FavoriteEntityType = 'EVENT' | 'SERVICE';

export interface Profile {
  id: string;
  email: string | null;
  full_name: string | null;
  role: AppRole;
  created_at: string;
}

export interface ProfileInsert {
  id?: string;
  email?: string | null;
  full_name?: string | null;
  role?: AppRole;
  created_at?: string;
}

export interface ProfileUpdate {
  email?: string | null;
  full_name?: string | null;
  role?: AppRole;
}

export interface Venue {
  id: string;
  name: string;
  address_street: string;
  address_city: string;
  address_state: string;
  address_zip: string;
  latitude: number | null;
  longitude: number | null;
  website_url: string | null;
  status: AppStatus;
  created_by: string;
  created_at: string;
}

export interface VenueInsert {
  id?: string;
  name: string;
  address_street: string;
  address_city: string;
  address_state: string;
  address_zip: string;
  latitude?: number | null;
  longitude?: number | null;
  website_url?: string | null;
  status?: AppStatus;
  created_by: string;
  created_at?: string;
}

export interface VenueUpdate {
  name?: string;
  address_street?: string;
  address_city?: string;
  address_state?: string;
  address_zip?: string;
  latitude?: number | null;
  longitude?: number | null;
  website_url?: string | null;
  status?: AppStatus;
}

export interface Discipline {
  id: number;
  name: string;
  slug: string;
}

export interface DisciplineInsert {
  id?: number;
  name: string;
  slug: string;
}

export interface DisciplineUpdate {
  name?: string;
  slug?: string;
}

export interface SanctioningBody {
  id: number;
  name: string;
  slug: string;
  website_url: string | null;
}

export interface SanctioningBodyInsert {
  id?: number;
  name: string;
  slug: string;
  website_url?: string | null;
}

export interface SanctioningBodyUpdate {
  name?: string;
  slug?: string;
  website_url?: string | null;
}

export interface Event {
  id: string;
  title: string;
  description: string | null;
  venue_id: string;
  start_datetime: string;
  flyer_image_url: string | null;
  official_website_url: string | null;
  classes_details: string | null;
  status: AppStatus;
  created_by: string;
  created_at: string;
}

export interface EventInsert {
  id?: string;
  title: string;
  description?: string | null;
  venue_id: string;
  start_datetime: string;
  flyer_image_url?: string | null;
  official_website_url?: string | null;
  classes_details?: string | null;
  status?: AppStatus;
  created_by: string;
  created_at?: string;
}

export interface EventUpdate {
  title?: string;
  description?: string | null;
  venue_id?: string;
  start_datetime?: string;
  flyer_image_url?: string | null;
  official_website_url?: string | null;
  classes_details?: string | null;
  status?: AppStatus;
}

export interface EventDiscipline {
  event_id: string;
  discipline_id: number;
}

export interface EventDisciplineInsert {
  event_id: string;
  discipline_id: number;
}

export interface EventSanction {
  event_id: string;
  sanction_id: number;
}

export interface EventSanctionInsert {
  event_id: string;
  sanction_id: number;
}

export interface Service {
  id: string;
  name: string;
  category: string;
  description: string | null;
  phone: string | null;
  website_url: string | null;
  service_radius_miles: number;
  zip_code: string;
  status: AppStatus;
  created_by: string;
  created_at: string;
}

export interface ServiceInsert {
  id?: string;
  name: string;
  category: string;
  description?: string | null;
  phone?: string | null;
  website_url?: string | null;
  service_radius_miles: number;
  zip_code: string;
  status?: AppStatus;
  created_by: string;
  created_at?: string;
}

export interface ServiceUpdate {
  name?: string;
  category?: string;
  description?: string | null;
  phone?: string | null;
  website_url?: string | null;
  service_radius_miles?: number;
  zip_code?: string;
  status?: AppStatus;
}

export interface Favorite {
  id: string;
  user_id: string;
  entity_id: string;
  entity_type: FavoriteEntityType;
  created_at: string;
}

export interface FavoriteInsert {
  id?: string;
  user_id: string;
  entity_id: string;
  entity_type: FavoriteEntityType;
  created_at?: string;
}

export interface FavoriteUpdate {
  entity_id?: string;
  entity_type?: FavoriteEntityType;
}
`;

const ensureDir = (relativePath) => {
  const fullPath = path.join(root, relativePath);
  fs.mkdirSync(fullPath, { recursive: true });
};

const writeFileIfMissing = (relativePath, content) => {
  const fullPath = path.join(root, relativePath);
  if (fs.existsSync(fullPath)) {
    console.log(`[skip] ${relativePath} already exists`);
    return;
  }
  fs.mkdirSync(path.dirname(fullPath), { recursive: true });
  fs.writeFileSync(fullPath, content, 'utf8');
  console.log(`[write] ${relativePath}`);
};

directories.forEach(ensureDir);
writeFileIfMissing('docs/TASKS.md', tasksContent);
writeFileIfMissing('supabase/migrations/0000_init.sql', migrationSql);
writeFileIfMissing('types/database.ts', typesContent);

console.log('Scaffold complete.');
